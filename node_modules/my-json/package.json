{
  "_args": [
    [
      "my-json",
      "/home/niner/student-advisement-system"
    ]
  ],
  "_from": "my-json@latest",
  "_id": "my-json@0.0.8",
  "_inCache": true,
  "_installable": true,
  "_location": "/my-json",
  "_npmUser": {
    "email": "luffgd@gmail.com",
    "name": "geraintluff"
  },
  "_npmVersion": "1.2.18",
  "_phantomChildren": {},
  "_requested": {
    "name": "my-json",
    "raw": "my-json",
    "rawSpec": "",
    "scope": null,
    "spec": "latest",
    "type": "tag"
  },
  "_requiredBy": [
    "#USER"
  ],
  "_resolved": "https://registry.npmjs.org/my-json/-/my-json-0.0.8.tgz",
  "_shasum": "80690e1decb0f658e06012f5251938b399362184",
  "_shrinkwrap": null,
  "_spec": "my-json",
  "_where": "/home/niner/student-advisement-system",
  "author": {
    "name": "Geraint Luff"
  },
  "bugs": {
    "url": "https://github.com/geraintluff/my-json/issues"
  },
  "dependencies": {
    "async": "~0.2.9",
    "json-pointer": "0.0.4",
    "mysql": "~2.0.0-alpha9",
    "promise": "~3.2.0"
  },
  "description": "Using MySQL databases as JSON stores",
  "devDependencies": {
    "chai": "~1.8.1",
    "grunt": "~0.4.1",
    "grunt-mocha-test": "~0.7.0"
  },
  "directories": {},
  "dist": {
    "shasum": "80690e1decb0f658e06012f5251938b399362184",
    "tarball": "https://registry.npmjs.org/my-json/-/my-json-0.0.8.tgz"
  },
  "homepage": "https://github.com/geraintluff/my-json#readme",
  "keywords": [
    "json",
    "json-schema",
    "mysql"
  ],
  "license:": [
    {
      "type": "MIT",
      "url": "http://jsonary.com/LICENSE.txt"
    }
  ],
  "main": "main.js",
  "maintainers": [
    {
      "name": "geraintluff",
      "email": "luffgd@gmail.com"
    }
  ],
  "name": "my-json",
  "optionalDependencies": {},
  "readme": "# MyJSON - MySQL as JSON\n\nThis package provides an interface to a MySQL database, accessing data as JSON documents.\n\nQueries are performed using JSON Schema to provide powerful search constraints on the data.\n\n## Constructing a class\n\nYou generate a class using a config object.  This config file specifies:\n\n* which table to use\n* which column(s) to use for keys\n* what data types to supply to / expect from different columns\n* where in the resulting JSON document those values should go\n\n```javascript\nvar myJson = require('my-json');\n\nvar TestClass = myJson({\n\ttable: 'TestTable',\n\tkeyColumn: 'integer/id',\n\tcolumns: {\n\t\t'integer/id': 'id',\n\t\t'string/name': 'name',\n\t\t'json': 'json_remainder'\n\t}\n});\n```\n\nThis will work with a table structure like:\n\n```\n+----------+----------+----------------+\n|    id    |   name   | json_remainder |\n+----------+----------+----------------+\n|    5     |   blah   | {\"extra\": 20}  |\n+----------+----------+----------------+\n```\n\nColumns of the `json` type contain a JSON representation of any properties that are *not* accounted-for by any of the other columns.  This table row therefore corresponds to a document like:\n\n```json\n{\n    \"id\": 5,\n    \"name\": \"blah\",\n    \"extra\": 20\n}\n```\n\nCurrently it only supports plain objects (taken from a single row), but support for arrays (as table joins) is planned - see the PHP equivalent [JSON Store](https://github.com/geraintluff/json-store) for what's planned.\n\n## Binding to a MySQL connection\n\nFor all the operations, you can either supply a MySQL connection each time, or you can bind a connection.\n\nBinding also creates a cache - this means that if the same document is returned by two different queries, then they will be represented by the same instance.  These caches are expected to be temporary (perhaps once per request for a web-server).\n\n```javascript\nvar mysql = require('mysql');\nvar connection = mysql.createConnection({...});\n\nvar BoundTestClass = TestClass.cacheWith(connection);\n```\n\n## Loading, saving, editing\n\n### Open:\n\n```javascript\nTestClass.open(connection, 5, function (err, result) {...});\nBoundTestClass.open(5, function (err, result) {...});\n```\n\nThe arguments given to `open()` should match (length and order) the columns specified in the config's `\"keyColumn\"` (or `\"keyColumns\"`) property.\n\nIf found, `result` will be an instance of the appropriate class - otherwise, it will be `undefined`.\n\n### Search (with JSON Schema):\n\n```javascript\nvar schema = {\n\ttype: \"object\",\n\tproperties: {\n\t\t\"id\": {\"enum\": [5]}\n\t}\n};\n\nTestClass.search(connection, schema, function (err, results) {...});\nBoundTestClass.search(schema, function (err, results) {...});\n```\n\nCurrently, the only schema keywords supported are `properties` and `enum`, but support for all validation keywords is planned.\n\n### Save:\n\n```javascript\nTestClass.save(connection, testObj, function (err, results) {...});\nBoundTestClass.save(testObj, function (err, results) {...});\n```\n\n### Create:\n\nCreation is performed by saving an object that is missing a key column:\n\n```javascript\nvar newObj = new TestClass();\nnewObj.name = 'test';\n\nTestClass.save(connection, testObj, function (err, results) {...});\n// or:\nBoundTestClass.save(testObj, function (err, results) {...});\n\nnewObj.id; // populated using the auto-increment, if there is one\n```\n\n### Remove/delete:\n\n```javascript\nTestClass.remove(connection, testObj, function (err, results) {...});\nBoundTestClass.remove(testObj, function (err, results) {...});\n```\n\n### Promises\n\nFor the above methods/functions that take a callback as a final argument, the callback can be omitted.\n\nIf the callback is omitted, then a Promise object is returned instead (from [this module](https://npmjs.org/package/promise)).",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/geraintluff/my-json.git"
  },
  "scripts": {
    "test": "grunt mochaTest"
  },
  "version": "0.0.8"
}
